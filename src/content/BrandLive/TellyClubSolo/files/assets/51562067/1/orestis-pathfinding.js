!function(t){var e={};function i(s){if(e[s])return e[s].exports;var n=e[s]={i:s,l:!1,exports:{}};return t[s].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.m=t,i.c=e,i.d=function(t,e,s){i.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:s})},i.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)i.d(s,n,function(e){return t[e]}.bind(null,n));return s},i.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(e,"a",e),e},i.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},i.p="",i(i.s=0)}([function(t,e,i){"use strict";var s=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0});const n=s(i(1)),a=s(i(2)),r=s(i(3)),o=s(i(5));new n.default,new a.default,new r.default,new o.default,console.log("Orestis 3D Pathfinding v2.0.6")},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=class{constructor(){this.createPcScript()}createPcScript(){const t=pc.createScript("orestisAgent");this.attachAttributes(t),t.prototype.initialize=function(){let t;this.agentId=void 0,this.crowd=void 0,pc.events.attach(this.entity),this.on("attr",()=>{window.clearTimeout(t),t=window.setTimeout(this.updateAgentAttributes.bind(this),300)}),this.entity.on("OrestisPathfinding:updateAgentAttributes",this.updateAgentAttributes,this)},t.prototype.onAddAgent=function(t,e){this.agentId=t,this.crowd=e},t.prototype.updateAgentAttributes=function(){this.crowd.updateAgentParameters(this.agentId,{radius:this.radius,height:this.height,maxAcceleration:this.maxAcceleration,maxSpeed:this.maxSpeed,collisionQueryRange:this.collisionQueryRange,pathOptimizationRange:this.pathOptimizationRange,separationWeight:this.separationWeight,stopDistance:this.stopDistance,orientAgent:this.orientAgent,orientInertia:this.orientInertia})}}attachAttributes(t){t.attributes.add("radius",{type:"number",default:.5,min:0,title:"Radius",description:"Agent radius. [Limit: >= 0]"}),t.attributes.add("height",{type:"number",default:1,min:0,title:"Height",description:"Agent height. [Limit: >= 0]"}),t.attributes.add("maxAcceleration",{type:"number",default:1,min:0,title:"Max Acceleration",description:"Maximum allowed acceleration. [Limit: >= 0]"}),t.attributes.add("maxSpeed",{type:"number",default:1,min:0,title:"Max Speed",description:"Maximum allowed speed. [Limit: >= 0]"}),t.attributes.add("collisionQueryRange",{type:"number",default:.5,min:0,title:"Collision Query Range",description:"Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]"}),t.attributes.add("pathOptimizationRange",{type:"number",default:0,min:0,title:"Path Optimization Range",description:"The path visibility optimization range. [Limit: > 0]"}),t.attributes.add("separationWeight",{type:"number",default:1,min:0,title:"Separation Weight",description:"How aggressive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]"}),t.attributes.add("stopDistance",{type:"number",default:0,title:"Stop Distance",description:"The distance from the path end point this agent should stop at. If 0.0 is provided the agent will reach as close as possible to the end point."}),t.attributes.add("orientInertia",{type:"number",default:.1,title:"Orient Inertia",description:"How smoothly the agent entity will rotate to orient itself."}),t.attributes.add("orientAgent",{type:"boolean",default:!0,title:"Orient Agent",description:"If selected the agent entity will automatically orient itself on the Y axis to look at the next point on the path."})}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});e.default=class{constructor(){this.createPcScript()}createPcScript(){const t=pc.createScript("orestisObstacle");this.attachAttributes(t),t.prototype.initialize=function(){this.pathfinder=void 0,this.obstacleRef=void 0,this.state=this.initialState,this.obstaclePos=this.entity.getPosition().clone(),this.entity.on("OrestisPathfinding:initializeObstacle",this.initializeObstacle,this),this.on("state",(function(t){this.updateObstacle(t)}),this)},t.prototype.initializeObstacle=function(t){var e,i,s;if(t)this.pathfinder=t;else{if(!this.pathfinderEntity)return;this.pathfinder=null===(s=null===(i=null===(e=this.pathfinderEntity)||void 0===e?void 0:e.script)||void 0===i?void 0:i.orestisPathfinding)||void 0===s?void 0:s.pathfinder}this.updateObstacle(this.state)},t.prototype.updateObstacle=function(t){this.state=!0===t;const e=this.pathfinder;if(!0===t){let t;switch(this.obstacleType){case"box":t=e.addBoxObstacle(this.obstaclePos,this.boxExtents,this.boxYAngle*pc.math.DEG_TO_RAD);break;case"cylinder":t=e.addCylinderObstacle(this.obstaclePos,this.cylinderRadius,this.cylinderHeight)}this.obstacleRef=t}else e.removeObstacle(this.obstacleRef),this.obstacleRef=void 0,e.navMesh.update()}}attachAttributes(t){t.attributes.add("pathfinderEntity",{type:"entity",title:"Pathfinder",description:"Drag and drop the pathfinder entity this obstacle should interact with. Updating this requires regenerating the navmesh or reloading your app"}),t.attributes.add("obstacleType",{type:"string",default:"box",title:"Obstacle Type",description:"Set the type of the obstacle shape.",enum:[{Box:"box"},{Cylinder:"cylinder"}]}),t.attributes.add("boxExtents",{type:"vec3",default:[1,1,1],title:"Box Extents",description:"The box extents on each axis."}),t.attributes.add("boxYAngle",{type:"number",default:0,min:0,max:360,title:"Box Y Angle",description:"The angle of the box orientation on the Y axis."}),t.attributes.add("cylinderRadius",{type:"number",default:1,min:0,title:"Cylinder Radius",description:"The cylinder radius."}),t.attributes.add("cylinderHeight",{type:"number",default:2,min:0,title:"Cylinder Height",description:"The cylinder height."}),t.attributes.add("initialState",{type:"boolean",default:!0,title:"Initial State",description:"If the obstacle will be enabled or disabled when the navmesh is generated."})}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const s=i(4);e.default=class{constructor(){this.createPcScript()}createPcScript(){const t=pc.createScript("orestisCrowd");this.attachAttributes(t),t.prototype.initialize=function(){this.pathfinder=void 0,this.crowd=void 0,this.agentsList=void 0,this.activeAgents=void 0,this.debugPath=void 0,this.debugColors=void 0,this.activeDestination=void 0,this.debugLineColor=new pc.Color(1,1,1,.5),pc.events.attach(this.entity),this.entity.on("OrestisPathfinding:moveCrowdTo",(function(t,e){this.moveCrowdTo(null,t,e)}),this),this.entity.on("OrestisPathfinding:moveAgentsTo",(function(t,e,i){this.moveCrowdTo(t,e,i)}),this),this.entity.on("OrestisPathfinding:stopCrowd",(function(){this.stopCrowd(null)}),this),this.entity.on("OrestisPathfinding:stopAgents",(function(t){this.stopCrowd(t)}),this),this.entity.on("OrestisPathfinding:teleportAgentsTo",(function(t,e,i){this.teleportAgentsTo(t,e)}),this),this.entity.on("OrestisPathfinding:getPath",(function(t,e){"function"==typeof e&&e(this.getPath(t))}),this),this.on("attr",(function(t,e){this.initializeCrowd()}))},t.prototype.initializeCrowd=function(t){t&&(this.pathfinder=t),this.crowd&&this.crowd.destroy(),this.crowd=new s.OrestisCrowd(this,this.pathfinder,this.maxAgents,this.maxAgentRadius),this.assignAgents()},t.prototype.destroyCrowd=function(){this.crowd&&this.crowd.destroy(),this.crowd=void 0},t.prototype.assignAgents=function(){this.agentsList={},this.agents.forEach(t=>{var e;const i=null===(e=null==t?void 0:t.script)||void 0===e?void 0:e.orestisAgent;if(!i||!i.enabled)return!0;const s=this.crowd.addAgent(t,{radius:i.radius,height:i.height,maxAcceleration:i.maxAcceleration,maxSpeed:i.maxSpeed,collisionQueryRange:i.collisionQueryRange,pathOptimizationRange:i.pathOptimizationRange,separationWeight:i.separationWeight,stopDistance:i.stopDistance,orientAgent:i.orientAgent,orientInertia:i.orientInertia});i.onAddAgent(s,this.crowd),this.agentsList[t._guid]=s})},t.prototype.moveCrowdTo=function(t,e,i){if(!this.crowd)return;let s,n;t?(n=[],t.forEach(t=>{n.push(this.agentsList[t._guid])})):n=this.crowd.getAgents(),n.forEach(t=>{s=this.pathfinder.getClosestPoint(e),!0===this.isPointCloseToSelected(s,e)&&this.crowd.agentGoto(t,s)}),this.activeAgents=n,this.activeDestination=s.clone()},t.prototype.stopCrowd=function(t){if(!this.crowd)return;let e;t?(e=[],t.forEach(t=>{e.push(this.agentsList[t._guid])})):e=this.crowd.getAgents(),e.forEach(t=>{this.crowd.agentStop(t)}),this.activeAgents=void 0,this.activeDestination=void 0},t.prototype.isPointCloseToSelected=function(t,e){let i=!0;const s=this.pathfinder.parameters.queryExtent;return Math.abs(t.x-e.x)>s.x&&(i=!1),i&&Math.abs(t.y-e.y)>s.y&&(i=!1),i&&Math.abs(t.z-e.z)>s.z&&(i=!1),i},t.prototype.teleportAgentsTo=function(t,e){if(!this.crowd)return;let i,s;t?(s=[],t.forEach(t=>{s.push(this.agentsList[t._guid])})):s=this.crowd.getAgents(),s.forEach(t=>{i=this.pathfinder.getClosestPoint(e),!0===this.isPointCloseToSelected(i,e)&&(this.crowd.agentTeleport(t,i),!1===this.crowd.isAgentActive(t)&&this.crowd.getAgentEntity(t).setPosition(i))}),this.activeAgents=void 0,this.activeDestination=void 0},t.prototype.getPath=function(t){if(!this.crowd||!this.activeDestination)return;let e;e=t&&t.length>0?t:this.agents;const i=this.pathfinder,s={};return e.forEach(t=>{const e=i.computePath(i.getClosestPoint(t.getPosition()),this.activeDestination);s[t._guid]=[];const n=s[t._guid];e.forEach(t=>{n.push(t.clone())})}),s},t.prototype.calculateDebugLines=function(){const t=this.pathfinder,e=this.activeAgents;this.debugPath=[],this.debugColors=[],e.forEach(e=>{const i=this.crowd.getAgentEntity(e);if(!i)return!0;const s=t.computePath(t.getClosestPoint(i.getPosition()),this.activeDestination);s.forEach((t,e)=>{if(0===e)return!0;const i=s[e-1];this.debugPath.push(i),this.debugPath.push(t),this.debugColors.push(this.debugLineColor),this.debugColors.push(this.debugLineColor)})})},t.prototype.update=function(){this.activeDestination&&(this.calculateDebugLines(),this.app.renderLines(this.debugPath,this.debugColors))}}attachAttributes(t){t.attributes.add("pathfinderEntity",{type:"entity",title:"Pathfinder",description:"Drag and drop the pathfinder entity this crowd should interact with. Updating this requires regenerating the navmesh or reloading your app"}),t.attributes.add("agents",{type:"entity",array:!0,title:"Agents",description:"Assigns agents to this crowd."}),t.attributes.add("maxAgents",{type:"number",default:1,min:1,title:"Max Agents",description:"The maximum number of agents allowed on this crowd."}),t.attributes.add("maxAgentRadius",{type:"number",default:.1,min:0,title:"Max Agent Radius",description:"The maximum radius an agent can have."})}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.OrestisCrowd=void 0;e.OrestisCrowd=class{constructor(t,e,i,s){this.vec=new pc.Vec3,this.vec2=new pc.Vec3,this.vec3=new pc.Vec3,this.recastCrowd={},this.entities=new Array,this.agents=new Array,this.agentsActive=new Array,this.agentsTargetPoint=new Array,this.script=t,this.app=t.app,this.pathfinder=e,this.recastCrowd=new this.pathfinder.RECAST.Crowd(i,s,this.pathfinder.navMesh.getNavMesh()),this.agentScriptParameters=[],this.agentCurrentAngleY=[],this.updateRef=this.update.bind(this),this.app.on("update",this.updateRef)}destroy(){this.recastCrowd&&this.recastCrowd.destroy()}addAgent(t,e){var i=new this.pathfinder.RECAST.dtCrowdAgentParams;i.radius=e.radius,i.height=e.height,i.maxAcceleration=e.maxAcceleration,i.maxSpeed=e.maxSpeed,i.collisionQueryRange=e.collisionQueryRange,i.pathOptimizationRange=e.pathOptimizationRange,i.separationWeight=e.separationWeight,i.updateFlags=7,i.obstacleAvoidanceType=0,i.queryFilterType=0,i.userData=0;const s=this.vec3;this.pathfinder.getRandomPointAround(t.getPosition(),.25,s);var n=this.recastCrowd.addAgent(new this.pathfinder.RECAST.Vec3(s.x,s.y,s.z),i);return this.entities.push(t),this.agents.push(n),this.agentScriptParameters[n]=e,this.agentCurrentAngleY[n]=t.getEulerAngles().y,n}getAgentPosition(t,e){const i=this.recastCrowd.getAgentPosition(t),s=-.75*this.pathfinder.parameters.cellHeight;return e?e.set(i.x,i.y+s,i.z):new pc.Vec3(i.x,i.y+s,i.z)}getAgentVelocity(t,e){var i=this.recastCrowd.getAgentVelocity(t);return e?e.set(i.x,i.y,i.z):new pc.Vec3(i.x,i.y,i.z)}getAgentNextTargetPath(t,e){var i=this.recastCrowd.getAgentNextTargetPath(t);return e?e.set(i.x,i.y,i.z):new pc.Vec3(i.x,i.y,i.z)}getAgentState(t){return this.recastCrowd.getAgentState(t)}getAgentEntity(t){return this.entities[t]}getAgentIndex(t){return this.entities.findIndex(e=>e._guid===t._guid)}overOffmeshConnection(t){return this.recastCrowd.overOffmeshConnection(t)}agentGoto(t,e){this.recastCrowd.agentGoto(t,new this.pathfinder.RECAST.Vec3(e.x,e.y,e.z)),this.agentsTargetPoint[t]||(this.agentsTargetPoint[t]=new pc.Vec3),this.agentsTargetPoint[t].copy(e);-1===this.agentsActive.indexOf(t)&&this.agentsActive.push(t)}agentStop(t){const e=this.getAgentEntity(t).getPosition();this.agentTeleport(t,e);const i=this.agentsActive.indexOf(t);i>-1&&this.agentsActive.splice(i,1)}isAgentActive(t){return this.agentsActive.indexOf(t)>-1}agentTeleport(t,e){this.recastCrowd.agentTeleport(t,new this.pathfinder.RECAST.Vec3(e.x,e.y,e.z))}updateAgentParameters(t,e){var i=this.recastCrowd.getAgentParameters(t);void 0!==e.radius&&(i.radius=e.radius),void 0!==e.height&&(i.height=e.height),void 0!==e.maxAcceleration&&(i.maxAcceleration=e.maxAcceleration),void 0!==e.maxSpeed&&(i.maxSpeed=e.maxSpeed),void 0!==e.collisionQueryRange&&(i.collisionQueryRange=e.collisionQueryRange),void 0!==e.pathOptimizationRange&&(i.pathOptimizationRange=e.pathOptimizationRange),void 0!==e.separationWeight&&(i.separationWeight=e.separationWeight),this.agentScriptParameters[t]=e,this.recastCrowd.setAgentParameters(t,i)}removeAgent(t){this.recastCrowd.removeAgent(t);var e=this.agents.indexOf(t);e>-1&&(this.agents.splice(e,1),this.entities.splice(e,1))}getAgents(){return this.agents}update(t){this.pathfinder.navMesh.update();var e=this.pathfinder.getTimeStep(),i=this.pathfinder.getMaximumSubStepCount();if(e<=.001)this.recastCrowd.update(t);else{var s=Math.floor(t/e);i&&s>i&&(s=i),s<1&&(s=1);var n=t/s;for(let t=0;t<s;t++)this.recastCrowd.update(n)}for(let e=0;e<this.agents.length;e++){if(-1===this.agentsActive.indexOf(e))continue;const i=this.agentScriptParameters[e],s=this.entities[e],n=this.getAgentPosition(this.agents[e],this.vec3);if(i.stopDistance>0){if(this.agentsTargetPoint[e].distance(n)<=i.stopDistance){this.agentStop(e);continue}}if(s.setPosition(n),i.orientAgent){const a=this.getAgentVelocity(e,this.vec2);if(a.length()>.2){const r=this.vec.copy(n).add(a.scale(3)),o=this.vec3.set(r.x,n.y,r.z);s.lookAt(o.x,o.y,o.z);const h=s.getEulerAngles(),d=h.y;this.agentCurrentAngleY[e]=pc.math.lerp(this.agentCurrentAngleY[e],d,i.orientInertia*t),s.setEulerAngles(h.x,this.agentCurrentAngleY[e],h.z)}}}}setDefaultQueryExtent(t){let e=new this.pathfinder.RECAST.Vec3(t.x,t.y,t.z);this.recastCrowd.setDefaultQueryExtent(e)}getDefaultQueryExtent(t){let e=this.recastCrowd.getDefaultQueryExtent();return t?t.set(e.x,e.y,e.z):new pc.Vec3(e.x,e.y,e.z)}getCorners(t){let e;const i=this.recastCrowd.getPath(t),s=i.getPointCount();var n=[];for(e=0;e<s;e++){let t=i.getPoint(e);n.push(new pc.Vec3(t.x,t.y,t.z))}return n}dispose(){this.recastCrowd.destroy(),this.app.off("update",this.updateRef),this.updateRef=void 0}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const s=i(6);e.default=class{constructor(){this.createPcScript()}createPcScript(){const t=pc.createScript("orestisPathfinding");this.attachAttributes(t),t.prototype.postInitialize=function(){let t;this.pathfinder=new s.OrestisPathfinder(this),pc.events.attach(this.entity),this.on("attr",()=>{window.clearTimeout(t),t=window.setTimeout(()=>{this.pathfinder.onAttrUpdate()},300)}),this.entity.on("OrestisPathfinding:findPath",this.findPath,this),this.onEventStart?this.app.once(this.onEventStart,(function(){this.pathfinder.createNavMesh()}),this):this.pathfinder.createNavMesh()},t.prototype.findPath=function(t,e,i){i(this.pathfinder.computePath(t,e))}}attachAttributes(t){t.attributes.add("cellSize",{type:"number",default:.25,min:0,title:"Cell Size",description:"XZ plane cell size, used to calculate the grid size based on the bounding box of the selected scene. [Limit: >= 0]"}),t.attributes.add("cellHeight",{type:"number",default:.25,min:0,title:"Cell Height",description:"Y-axis cell size, used to calculate the grid size based on the bounding box of the selected scene. [Limit: >= 0]"}),t.attributes.add("walkableHeight",{type:"number",default:1,min:0,title:"Walkable Height",description:"Minimum floor to ceiling height that will still allow the floor area to be considered walkable. [Limit: >=0]"}),t.attributes.add("walkableRadius",{type:"number",default:1,min:0,title:"Walkable Radius",description:"The distance to erode/shrink the walkable area of the heightfield away from obstructions. [Limit: >=0]"}),t.attributes.add("walkableClimb",{type:"number",default:1,min:0,title:"Walkable Climb",description:"Maximum ledge height that is considered to still be traversable. [Limit: >=0]"}),t.attributes.add("walkableSlopeAngle",{type:"number",default:35,min:0,max:90,title:"Walkable Slope Angle",description:"The maximum slope that is considered walkable. [Limits: 0 <= value < 90]"}),t.attributes.add("regionMinSize",{type:"number",default:8,min:0,title:"Region Min Size",description:"The minimum number of cells allowed to form isolated island areas. [Limit: >=0]"}),t.attributes.add("regionMergeSize",{type:"number",default:20,min:0,title:"Region Merge Size",description:"Any regions with a span count smaller than this value will, if possible, be merged with larger regions. [Limit: >=0]"}),t.attributes.add("edgeMaxLen",{type:"number",default:12,min:0,title:"Edge Max Length",description:"The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0]"}),t.attributes.add("edgeMaxError",{type:"number",default:1.3,min:0,title:"Edge Max Error",description:"The maximum distance a simplfied contour's border edges should deviate the original raw contour. [Limit: >=0]"}),t.attributes.add("vertsPerPoly",{type:"number",default:6,min:3,title:"Max Verts Per Poly",description:"The maximum number of vertices allowed for polygons generated during the contour to polygon conversion process. [Limit: >= 3]"}),t.attributes.add("detailSampleDist",{type:"number",default:6,min:.9,title:"Detail Sample Dist",description:"Sets the sampling distance to use when generating the detail mesh, for height detail only. [Limits: >= 0.9]"}),t.attributes.add("detailSampleMaxError",{type:"number",default:1,min:0,title:"Detail Sample Max Error",description:"The maximum distance the detail mesh surface should deviate from heightfield data, for height detail only. [Limit: >=0]"}),t.attributes.add("tileSize",{type:"number",default:0,min:0,title:"Tile Size",description:"The width/height size of tile's on the xz-plane. If you plan to use obstacles the tileSize should be > 0. [Limit: >= 0]"}),t.attributes.add("borderSize",{type:"number",default:0,min:0,title:"Border Size",description:"The size of the non-navigable border around the heightfield. [Limit: >= 0]"}),t.attributes.add("debugNavMesh",{type:"boolean",default:!1,title:"Debug Nav Mesh",description:"If enabled the generated nav mesh will be rendered."}),t.attributes.add("queryExtent",{type:"vec3",default:[1,1,1],title:"Query Extent",description:"Set the Bounding box extent for doing spatial queries (getClosestPoint, getRandomPointAround etc.)."}),t.attributes.add("excludeTags",{type:"string",default:"navmesh-exclude",title:"Exclude Tags",description:"A comma separated list of entity tags to exclude from the navmesh."}),t.attributes.add("onEventStart",{type:"string",title:"On Event Start",description:"Run the navmesh generator when this app wide event fires, if empty the navmesh will be generated on initialize."}),t.attributes.add("onEventReady",{type:"string",title:"On Event Ready",description:"Fire a custom event when the navmesh generation finished."})}}},function(t,e,i){"use strict";var s=this&&this.__awaiter||function(t,e,i,s){return new(i||(i=Promise))((function(n,a){function r(t){try{h(s.next(t))}catch(t){a(t)}}function o(t){try{h(s.throw(t))}catch(t){a(t)}}function h(t){var e;t.done?n(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,o)}h((s=s.apply(t,e||[])).next())}))};Object.defineProperty(e,"__esModule",{value:!0}),e.OrestisPathfinder=void 0;const n=i(7);e.OrestisPathfinder=class{constructor(t,e=Recast){this.RECAST={},this._maximumSubStepCount=10,this._timeStep=1/60,this.parameters=t,this.app=t.app,this.parentEntity=t.entity,"function"==typeof e?e(this.RECAST):this.RECAST=e,this.isSupported()?this.setTimeStep():console.log("Orestis 3D Pathfinding, RecastJS is not available. Please make sure you included the js file.")}onAttrUpdate(){return s(this,void 0,void 0,(function*(){this.debugEntity&&(this.debugEntity.model.meshInstances[0].material.destroy(),this.debugEntity.model.meshInstances[0].mesh.destroy(),this.debugEntity.destroy(),this.debugEntity=void 0),this.createNavMesh()}))}setTimeStep(t=1/60){this._timeStep=t}getTimeStep(){return this._timeStep}setMaximumSubStepCount(t=10){this._maximumSubStepCount=t}getMaximumSubStepCount(){return this._maximumSubStepCount}createNavMesh(){if(this.navMesh){this.getCrowdEntities().forEach(t=>{t.script.orestisCrowd.destroyCrowd()}),this.navMesh.destroy()}const t=new this.RECAST.rcConfig,e=this.parameters;t.borderSize=e.borderSize?e.borderSize:0,t.tileSize=e.tileSize?e.tileSize:0,t.cs=e.cellSize,t.ch=e.cellHeight,t.walkableSlopeAngle=e.walkableSlopeAngle?e.walkableSlopeAngle:35,t.walkableHeight=e.walkableHeight,t.walkableClimb=e.walkableClimb,t.walkableRadius=e.walkableRadius,t.maxEdgeLen=e.edgeMaxLen,t.maxSimplificationError=e.edgeMaxError,t.minRegionArea=e.regionMinSize,t.mergeRegionArea=e.regionMergeSize,t.maxVertsPerPoly=e.vertsPerPoly,t.detailSampleDist=e.detailSampleDist,t.detailSampleMaxError=e.detailSampleMaxError;const i=new n.OrestisGeometry(this.parentEntity,e.excludeTags).getGeometry();this.navMesh=new this.RECAST.NavMesh;const s=performance.now();this.navMesh.build(i.positions,i.offset,i.indices,i.indices.length,t);const a=performance.now();console.log(`Orestis 3D Pathfinding, nav mesh generation for ${this.parentEntity.name} entity ${a-s} milliseconds.`),e.debugNavMesh&&this.createDebugNavMesh(),this.bootCrowds(),this.setDefaultQueryExtent(this.parameters.queryExtent)}getCrowdEntities(){const t=this.parentEntity._guid;return this.app.root.find(e=>e.script&&e.script.orestisCrowd&&e.script.orestisCrowd.pathfinderEntity&&e.script.orestisCrowd.pathfinderEntity._guid===t)}bootCrowds(){const t=this.parentEntity._guid;this.getCrowdEntities().forEach(t=>{t.script.orestisCrowd.initializeCrowd(this)});this.app.root.find(e=>e.script&&e.script.orestisObstacle&&e.script.orestisObstacle.pathfinderEntity&&e.script.orestisObstacle.pathfinderEntity._guid===t).forEach(t=>{t.script.orestisObstacle.initializeObstacle(this)})}createDebugNavMesh(t){var e=t?t.indices:null,i=t?t.positions:null;if(!t){e=[],i=[];var s=this.navMesh.getDebugNavMesh();let t=s.getTriangleCount();var n,a;for(n=0;n<3*t;n++)e.push(n);for(n=0;n<t;n++)for(a=0;a<3;a++){let t=s.getTriangle(n).getPoint(a);i.push(t.x,t.y,t.z)}}const r=new pc.Entity,o=new pc.StandardMaterial;o.emissive.set(.8,.8,.8,1),o.cull=pc.CULLFACE_FRONT,o.update();const h=new pc.GraphNode,d=new pc.Mesh(this.app.graphicsDevice);d.setPositions(i),d.setNormals(pc.calculateNormals(i,e)),d.setIndices(e),d.update();const c=new pc.MeshInstance(h,d,o),l=new pc.Model;l.graph=h,l.meshInstances.push(c),r.addComponent("model",{layers:[this.app.scene.layers.getLayerByName("World").id],castShadows:!1,receiveShadows:!1}),r.model.model=l,this.app.root.addChild(r),this.debugEntity=r}isSupported(){return void 0!==this.RECAST}getClosestPoint(t,e){var i=new this.RECAST.Vec3(t.x,t.y,t.z),s=this.navMesh.getClosestPoint(i);return e?e.set(s.x,s.y,s.z):new pc.Vec3(s.x,s.y,s.z)}getRandomPointAround(t,e,i){var s=new this.RECAST.Vec3(t.x,t.y,t.z),n=this.navMesh.getRandomPointAround(s,e);return i?i.set(n.x,n.y,n.z):new pc.Vec3(n.x,n.y,n.z)}moveAlong(t,e,i){var s=new this.RECAST.Vec3(t.x,t.y,t.z),n=new this.RECAST.Vec3(e.x,e.y,e.z),a=this.navMesh.moveAlong(s,n);return i?i.set(a.x,a.y,a.z):new pc.Vec3(a.x,a.y,a.z)}computePath(t,e){var i;let s=new this.RECAST.Vec3(t.x,t.y,t.z),n=new this.RECAST.Vec3(e.x,e.y,e.z),a=this.navMesh.computePath(s,n),r=a.getPointCount();var o=[];for(i=0;i<r;i++){let t=a.getPoint(i);o.push(new pc.Vec3(t.x,t.y,t.z))}return o}setDefaultQueryExtent(t){let e=new this.RECAST.Vec3(t.x,t.y,t.z);this.navMesh.setDefaultQueryExtent(e)}getDefaultQueryExtent(t){let e=this.navMesh.getDefaultQueryExtent();return t?t.set(e.x,e.y,e.z):new pc.Vec3(e.x,e.y,e.z)}buildFromNavmeshData(t){var e=t.length*t.BYTES_PER_ELEMENT,i=this.RECAST._malloc(e),s=new Uint8Array(this.RECAST.HEAPU8.buffer,i,e);s.set(t);let n=new this.RECAST.NavmeshData;n.dataPointer=s.byteOffset,n.size=t.length,this.navMesh=new this.RECAST.NavMesh,this.navMesh.buildFromNavmeshData(n),this.RECAST._free(s.byteOffset)}getNavmeshData(){let t=this.navMesh.getNavmeshData();var e=new Uint8Array(this.RECAST.HEAPU8.buffer,t.dataPointer,t.size),i=new Uint8Array(t.size);return i.set(e),this.navMesh.freeNavmeshData(t),i}addCylinderObstacle(t,e,i){return this.navMesh.addCylinderObstacle(new this.RECAST.Vec3(t.x,t.y,t.z),e,i)}addBoxObstacle(t,e,i){return this.navMesh.addBoxObstacle(new this.RECAST.Vec3(t.x,t.y,t.z),new this.RECAST.Vec3(e.x,e.y,e.z),i)}removeObstacle(t){this.navMesh.removeObstacle(t)}}},function(t,e,i){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.OrestisGeometry=void 0;e.OrestisGeometry=class{constructor(t,e){this.excludeTags=e,this.setParentEntity(t)}setParentEntity(t){t&&(this.parentEntity=t)}getMeshInstances(t){const e=[],i=this.excludeTags.split(","),s=t=>{const e=t.tags.list();let s=!1;return e.forEach(t=>{if(!s&&i.indexOf(t)>-1)return s=!0,!1}),s};return t.find((function(t){t.model&&t.model.meshInstances&&!1===s(t)&&t.model.meshInstances.forEach((function(t){e.push(t)}))})),t.model&&t.model.meshInstances&&!1===s(t)&&t.model.meshInstances.forEach((function(t){e.push(t)})),e}getMeshGeometry(t){const e=t.node.getWorldTransform(),i=t.mesh.vertexBuffer,s=new pc.VertexIterator(i),n=[],a=new pc.Vec3;for(let t=0;t<i.getNumVertices();t++){const t=s.element[pc.SEMANTIC_POSITION],i=t.array[t.index],r=t.array[t.index+1],o=t.array[t.index+2];a.set(i,r,o),e.transformPoint(a,a),n.push(a.x,a.y,a.z),s.next()}s.end();const r=t.mesh.indexBuffer[pc.RENDERSTYLE_SOLID],o=new Uint16Array(r.lock()),h=[],d=t.mesh.primitive[0].base,c=t.mesh.primitive[0].count;for(let t=0;t<c;t++)h.push(o[t+d]);return{vertices:n,indices:h,numIndices:c,numVertices:n.length/3}}getGeometry(){if(!this.parentEntity)return;const t=this.getMeshInstances(this.parentEntity);if(0===t.length)return;const e=[],i=[];let s=0,n=0;for(let a=0;a<t.length;a++){const r=t[a],o=this.getMeshGeometry(r);let h=0;for(let t=0;t<o.vertices.length;t+=3)i.push(o.vertices[t],o.vertices[t+1],o.vertices[t+2]),h++;for(let t=0;t<o.indices.length;t+=3)e.push(o.indices[t+2]+n,o.indices[t+1]+n,o.indices[t]+n);s+=o.vertices.length/3,n+=h}return{positions:i,indices:e,offset:s}}}}]);